### Программное решение задач с рекурсией

---

#### 1. **Простейший пример рекурсии**

**Код:**
```python
def f(n):
    if n <= 1:  # Базовый случай для выхода из рекурсии
        return 1
    else:
        return f(n-1) + f(n-2)  # Рекурсивный вызов

print(f(n))
```

**Комментарий:**  
Рекурсия — это функция, которая вызывает саму себя. Важно определить базовый случай (например, `n <= 1`), чтобы рекурсия завершилась.

---

#### 2. **Укорачиваем количество написанного кода**

**Было:**
```python
def f(n):
    if n < 3: return n + 3
    if n >= 3 and n % 3 == 0: return (n + 2) * f(n - 4)
    if n >= 3 and n % 3 != 0: return n + f(n - 1) + 2 * f(n - 2)
```

**Стало:**
```python
def f(n):
    if n < 3: return n + 3
    if n % 3 == 0: return (n + 2) * f(n - 4)
    return n + f(n - 1) + 2 * f(n - 2)
```

**Комментарий:**  
Убираем лишние проверки (`n >= 3`), так как они уже подразумеваются в условиях.

---

#### 3. **Корректируем функцию для удобного рекурсивного подсчета**

**Было:**
```python
def F(n):
    print('*')
    if n >= 1:
        print('*')
        F(n - 1)
        F(n - 3)
        print('*')
```

**Стало:**
```python
def f(n):
    k = 0
    k += 1  # Учитываем текущий уровень рекурсии
    if n >= 1:
        k += 2 + f(n - 1) + f(n - 3)  # Суммируем результаты рекурсивных вызовов
    return k
```

**Комментарий:**  
Меняем логику на подсчет количества операций вместо вывода символов.

---

#### 4. **Кэширование**

**Рукописный вариант:**
```python
cache = {}

def f(n):
    if n not in cache:
        if n == 1: cache[n] = 1
        else: cache[n] = f(n - 1) + 3 * g(n - 1)
    return cache[n]

def g(n):
    if n == 1: return 1
    return f(n - 1) - 2 * g(n - 1)
```

**С использованием `functools`:**
```python
from functools import lru_cache

@lru_cache(None)  # Кэшируем функцию f
def f(n):
    if n == 1: return 1
    return f(n - 1) + 3 * g(n - 1)

@lru_cache(None)  # Кэшируем функцию g
def g(n):
    if n == 1: return 1
    return f(n - 1) - 2 * g(n - 1)
```

**Комментарий:**  
Кэширование помогает избежать повторных вычислений для одних и тех же аргументов.

---

#### 5. **Заранее просчитываем значения функции**

**Код:**
```python
from functools import lru_cache

@lru_cache(None)
def f(n):
    if n < -100_000: return 1
    if n > 10: return f(n - 1) + 3 * f(n - 3) + 2
    return -f(n - 1)

# Последовательно сохраняем все результаты от -100_000 до 19
for i in range(-100_000, 20):
    f(i)

print(f(20))
```

**Комментарий:**  
Предварительный расчет значений ускоряет работу программы для больших $n$.

---

#### 6. **Обработка бесконечной рекурсии**

**Код:**
```python
def f(n):
    if n <= 5: return n
    if n % 4 == 0: return n + f(n / 2 - 1)
    return n + f(n + 2)  # Возрастает в бесконечность иногда

for n in range(1, 10000):
    try:
        print(n, f(n))
    except:
        pass  # Пропускаем числа с ошибкой
```

**Комментарий:**  
Используем блок `try-except`, чтобы игнорировать случаи бесконечной рекурсии.

---

#### 7. **Увеличение ограничения на количество рекурсий**

**Код:**
```python
from sys import setrecursionlimit

setrecursionlimit(10_000)  # Увеличиваем максимальную глубину рекурсии
...
```

**Комментарий:**  
По умолчанию Python ограничивает глубину рекурсии. Для сложных задач это ограничение можно увеличить.

---

### Аналитическое решение

#### **Пример 1**

**Условие:**  

Алгоритм вычисления функции $F(n)$ задан следующими соотношениями:

$$
\begin{aligned}
F(n) &= 1, \quad n = 1 \\
F(n) &= \frac{n}{2} + F(n-1), \quad (n > 1) \wedge (n \text{ четно}) \\
F(n) &= n + F(n-2), \quad (n > 1) \wedge (n \text{ нечетно})
\end{aligned}
$$

Чему равно $F(10000) - F(9993)$?

**Решение:**

$$
\begin{aligned}
F(10000) &= \frac{10000}{2} + F(9999) \\
F(9999) &= 9999 + F(9997) \\
F(9997) &= 9997 + F(9995) \\
F(9995) &= 9995 + F(9993) \\
F(10000) - F(9993) &= \frac{10000}{2} + 9999 + 9997 + 9995 + F(9993) - F(9993) \\
&= 5000 + 9999 + 9997 + 9995 = 34991
\end{aligned}
$$

**Основная идея:** Выражаем одно значение функции через другое, чтобы сократить большие $F(n)$.

---

### "Идейные" рекурсии

#### **Пример**

**Условие:**  
Алгоритм вычисления функции $F(n)$, где $n$ — целое неотрицательное число, задан следующим образом:

$$
\begin{aligned}
F(0) &= 0 \\
F(n) &= 1 + F(n // 2), \quad n > 0 \wedge (n \text{ нечетное}) \\
F(n) &= F(n / 2), \quad \text{в остальных случаях}
\end{aligned}
$$

Найдите количество значений $n$ на отрезке $[1, 1000000000]$, для которых $F(n) = 3$.

**Решение:**
1. Заметим, что функция считает количество единиц в двоичной записи числа $n$.
2. Для $F(n) = 3$ двоичная запись числа должна содержать ровно три единицы.
3. Перебираем все возможные комбинации позиций единиц.

**Код:**
```python
c = 0
for i in range(0, 50):  # Максимальная длина двоичной записи
    for j in range(i + 1, 50):
        for k in range(j + 1, 50):
            a = 2**i + 2**j + 2**k  # Число с тремя единицами в двоичной записи
            if a <= 1_000_000_000:
                c += 1
print(c)
```

**Ответ:** Количество таких чисел равно $c$
