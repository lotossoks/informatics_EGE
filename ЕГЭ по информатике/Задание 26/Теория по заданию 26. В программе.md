## Пример 1: Сохранение файлов на диск
### Условие
- На диске есть свободное место объемом `S`.
- Есть `N` пользователей с файлами.
- Нужно сохранить на диск файлы максимального количества пользователей.
- Среди сохранённых файлов нужно найти файл с максимальным размером при условии, что сохранено максимальное число пользователей.
### Входные данные
- `S` — свободное место на диске (≤ 100 000).
- `N` — количество пользователей (≤ 10 000).
- `N` чисел — объёмы файлов пользователей (≤ 100).
### Решение
```python
f = open('26.txt')
s, n = map(int, f.readline().split())  # Считываем S, N
a = [int(x) for x in f]  # Считываем размеры файлов
a.sort()  # Сортируем размеры файлов по возрастанию

# Первый вариант решения (через цикл for)
s1 = 0  # Сумма размеров сохранённых файлов
k = 0  # Количество сохранённых файлов
b = 0  # Размер последнего сохранённого файла
for i in range(n):
    if s1 + a[i] <= s:  # Если добавление нового файла не превышает лимит
        s1 += a[i]
        k += 1
        b = a[i]
        a[i] = 0  # Помечаем файл как сохранённый

# Пытаемся заменить последний сохранённый файл на файл большего размера
for i in range(n):
    if a[i] != 0 and s1 - b + a[i] <= s:
        s1 = s1 - b + a[i]
        b, a[i] = a[i], b  # Меняем файлы местами

print(k, b)

# Второй вариант решения (через цикл while и for)
b = []
a = [int(x) for x in a if x!=0]
# Сохраняем файлы, пока хватает места (через while)
while sum(b) + a[0] <= s:
    b.append(a.pop(0))  # Добавляем файл в список сохранённых и удаляем из списка файлов

# Сохраняем файлы, пока хватает места (через for)
# for i in range(len(a)):
#     if sum(b) + a[i] <= s:
#         b.append(a[i])
#         a[i] = 0
# a = [x for x in a if x != 0]

# Пытаемся заменить последний сохранённый файл на файл большего размера
for i in range(len(a)):
    if sum(b) - b[-1] + a[i] <= s:
        b[-1], a[i] = a[i], b[-1]  # Меняем файлы местами

print(k, b[-1])
```
### Основные идеи
- **Сортировка:** Сортировка файлов по возрастанию размера позволяет сначала сохранить самые маленькие файлы, максимизируя количество сохранённых файлов.
- **Жадный алгоритм:** Мы пытаемся сохранить как можно больше файлов, добавляя их в порядке возрастания размера.
- **Оптимизация:** После сохранения максимального количества файлов, мы пытаемся заменить последний сохранённый файл на файл большего размера, если это возможно без нарушения ограничения по объёму.

## Пример 2: Погрузка грузов
### Условие
- Есть грузовик с грузоподъёмностью `M`.
- Есть `N` грузов с известными массами.
- Сначала грузятся грузы массой от 180 до 200 кг по убыванию массы.
- Затем на оставшееся место загружается максимальное количество грузов (по возрастанию массы).
- Если вариантов несколько, выбирается тот, где самый тяжёлый груз максимален, затем второй по тяжести и т.д.
### Входные данные
- `N` — количество грузов.
- `M` — грузоподъёмность грузовика.
- `N` чисел — массы грузов.
### Требуется
* Определить количество и общую массу грузов, которые можно вывезти.
### Решение
```python
f = open('26.txt')
n, m = map(int, f.readline().split())
a = sorted(int(x) for x in f)  # Считываем и сортируем массы грузов по возрастанию
b = []  # Список для грузов от 180 до 200 кг

# Отбираем грузы от 180 до 200 кг
for i in range(n):
    if 180 <= a[i] <= 200:
        b.append(a[i])
        a[i] = 0
a = [x for x in a if x != 0]  # Убираем из списка a грузы, попавшие в b
b.sort(reverse=True)
# Сначала грузим обязательные грузы
m -= sum(b)

c = []  # Список для остальных грузов
# Загружаем оставшиеся грузы, пока хватает места
while sum(c) + a[0] <= m:
    c.append(a.pop(0))

c.sort(reverse=True)  # Сортируем по убыванию для оптимизации

# Пытаемся заменить грузы на более тяжёлые
for i in range(len(c)):
    for j in range(len(a)):
        if a[j] > c[i] and sum(c) - c[i] + a[j] <= m:
            c[i], a[j] = a[j], c[i]  # Меняем грузы местами

print(len(b + c), sum(b + c))
```
### Основные идеи
- **Разделение данных:** Разделяем грузы на две группы: обязательные (от 180 до 200 кг) и остальные.
- **Сортировка:** Сортируем обязательные грузы по убыванию, а остальные по возрастанию.
- **Жадный алгоритм:** Сначала загружаем обязательные грузы, затем добавляем остальные, пока хватает места.
- **Оптимизация:** Пытаемся заменить загруженные грузы на более тяжёлые из оставшихся, если это не нарушает ограничение по грузоподъёмности.

## Пример 3: Распределение архивов по дискам
### Условие
- Есть `K` дисков объёмом `V`.
- Есть `N` архивов с известными размерами.
- Архивы раскладываются по убыванию размера.
- Архив кладется на текущий диск, если не помещается, то на следующий (по кругу).
- Если архив не помещается ни на один диск, он откладывается в локальную папку.
### Требуется
Определить общий объём и количество отложенных архивов.
### Входные данные
- `V` — объём диска.
- `K` — количество дисков.
- `N` — количество архивов.
- `N` чисел — размеры архивов.
### Решение
```python
f = open('26.txt')
v, k, n = map(int, f.readline().split())
a = sorted([int(x) for x in f], reverse=True)  # Считываем и сортируем размеры архивов по убыванию
b = [0] * k  # Список для хранения занятого места на каждом диске
trash = []  # Список для отложенных архивов
last_disk = 0  # Индекс последнего использованного диска

for i in range(n):
    # Ищем подходящий диск, начиная со следующего после последнего использованного
    for j in range(last_disk, last_disk + k):
        current_disk = j % k
        if b[current_disk] + a[i] <= v:
            b[current_disk] += a[i]
            last_disk = current_disk  # Обновляем индекс последнего использованного диска
            break
    else:
        trash.append(a[i])  # Если подходящий диск не найден, откладываем архив

print(sum(trash), len(trash))
```
### Основные идеи
- **Сортировка:** Сортируем архивы по убыванию размера, чтобы сначала обрабатывать самые большие.
- **Циклический обход:** Используем остаток от деления для циклического обхода дисков.
- **Отслеживание состояния:** Храним информацию о занятом месте на каждом диске и индексе последнего использованного диска.

## Пример 4: Быстрый поиск по числам
### Условие
- Дан набор из `N` различных натуральных чисел.
- Нужно найти количество пар чисел с чётной суммой, среднее арифметическое которых также присутствует в наборе.
- Нужно определить наибольшее из таких средних арифметических.
### Входные данные
- `N` — количество чисел.
- `N` чисел (каждое число ≤ 10^9).
### Требуется
Вывести количество подходящих пар и наибольшее среднее арифметическое.
### Решение
```python
f = open('26.txt')
n = int(f.readline())
a = [int(x) for x in f]
b = set(a)  # Создаём множество из чисел для быстрого поиска
ans = []

for i in range(n):
    for j in range(i + 1, n):
        if (a[i] + a[j]) % 2 == 0:  # Проверяем чётность суммы
            sr = (a[i] + a[j]) // 2
            if sr in b:  # Проверяем наличие среднего арифметического в множестве
                ans.append(sr)

print(len(ans), max(ans))
```
### Основные идеи
- **Множество для быстрого поиска:** Использование множества вместо списка позволяет проверять наличие элемента за логарифмическое время, что значительно ускоряет решение.
- **Перебор пар:** Перебираем все возможные пары чисел.

## Пример 5: Зародыш бин. поиска
### Условие
- Дан набор из `N` различных натуральных чисел.
- Рассматриваются пары чисел с чётной суммой.
- Для каждой пары нужно проверить, что хотя бы половина элементов набора больше, чем среднее арифметическое пары.
- Нужно найти количество таких пар и наибольшее из средних арифметических этих пар.
### Входные данные
- `N` — количество чисел.
- `N` чисел.
### Требуется
Вывести количество подходящих пар и наибольшее среднее арифметическое.
### Решение
```python
f = open('26.txt')
n = int(f.readline())
a = [int(x) for x in f]
a.sort()  # Сортируем числа по возрастанию
ans = []

for i in range(n):
    for j in range(i + 1, n):
        if (a[i] + a[j]) % 2 == 0:  # Проверяем чётность суммы
            sr = (a[i] + a[j]) // 2
            # Проверяем, что хотя бы половина элементов больше среднего арифметического
            if sr < a[n // 2]:
                ans.append(sr)

print(len(ans), max(ans))
```

### Основные идеи
- **Сортировка:** Сортировка позволяет быстро определить, что хотя бы половина элементов больше среднего арифметического, сравнив его с элементом в середине отсортированного списка.
## Пример 6: Бин. поиск
### Условие
- Дан набор из `N` различных натуральных чисел.
- Для каждой пары чисел вычисляется `K` — количество чисел из набора, меньших среднего арифметического этой пары.
- Нужно найти количество пар с ненулевым значением `K`, кратным 100.
- Нужно определить наибольшее значение `K` среди таких пар.
### Входные данные
- `N` — количество чисел.
- `N` чисел (каждое число ≤ 10^9).
### Требуется
Вывести количество подходящих пар и наибольшее значение `K`.
### Решение
```python
from bisect import bisect_left

f = open('26.txt')
n = int(f.readline())
a = [int(x) for x in f]
a.sort()  # Сортируем числа по возрастанию
ans = []

# Способ 1: Без бин. поиска
# for i in range(n):
#     for j in range(i + 1, n):
#         sr = (a[i] + a[j]) / 2
#         count = i + 1  # Количество чисел, меньших среднего арифметического
#         for k in range(i + 1, n):
#             if a[k] < sr:
#                 count += 1
#             else:
#                 break
#         if count % 100 == 0 and count !=0:
#             ans.append(count)

# Способ 2: С бин. поиском
for i in range(n):
    for j in range(i + 1, n):
        sr = (a[i] + a[j]) / 2
        count = bisect_left(a, sr)  # Находим количество чисел, меньших среднего арифметического
        if count % 100 == 0 and count !=0:
            ans.append(count)

print(len(ans), max(ans))
```
### Основные идеи
- **Сортировка:** Сортировка позволяет использовать бинарный поиск для быстрого нахождения количества чисел, меньших среднего арифметического.
- **Бин. поиск (bisect_left):** Функция `bisect_left` находит индекс, куда можно вставить элемент, сохраняя порядок сортировки. Этот индекс равен количеству элементов, меньших вставляемого.
- **Оптимизация перебора:** В первом варианте решения, мы начинаем с `count=i+1`, потому что знаем, что все элементы до `i+1` точно меньше среднего арифметического.

## Пример 7: Освещение дороги
### Условие
- На дороге установлены фонари, каждый из которых освещает участок длиной 40 метров (по 20 метров в каждую сторону).
- Нужно найти 500-й неосвещённый участок дороги.
### Требуется
Определить расстояние от начала дороги до начала 500-го неосвещённого участка и его длину.
### Входные данные
- Количество фонарей.
- Для каждого фонаря: расстояние от начала дороги до опоры фонаря (≤ 150 000 метров).
### Решение
```python
f = open('26.txt')
n = int(f.readline())
road = [0] * 150_001  # Массив для хранения освещённости участков дороги

# Заполняем разметку освещенных участков
for _ in range(n):
    lamp = int(f.readline())
    left = max(0, lamp - 20)
    right = min(150_000, lamp + 20)
    road[left] += 1
    road[right] -= 1

# Ищем неосвещённые участки
k = 0  # Текущее количество фонарей, освещающих участок
st = -1 # Начало неосвещённого участка
end = 0 # Конец неосвещённого участка
count = 0 # Счётчик неосвещённых участков
for i in range(150_001):
    k0 = k # Количество на предыдущем шаге
    k += road[i]
    if k == 0 and st == -1:
        st = i
    if k0 == 0 and k > 0:
        end = i
        count += 1
        if count == 500:
            print(st, end - st)
            break
        st = -1
```
### Основные идеи
- **Массив для хранения освещённости:** Создаём массив, где каждый элемент соответствует участку дороги длиной 1 метр. Увеличиваем значение элемента на 1, если участок освещается фонарём, и уменьшаем на 1, если фонарь заканчивает освещать этот участок.
- **Префиксные суммы:** Значение `k` на каждом шаге вычисляется как сумма значений в массиве `road` до текущего индекса. Это позволяет определить, освещён ли участок или нет.
- **Подсчёт неосвещённых участков:** Проходим по массиву и считаем неосвещённые участки, отслеживая их начало и конец.

## Пример 8: Задача о рюкзаке
### Условие
- Есть `K` гирь, веса каждой различны.
### Требуется
1. Сколько существует способов набрать ими вес `M`?
2. Какой вес можно выдать наибольшим количеством способов?
### Решение
```python
f = open('26.txt')
n, m = map(int, f.readline().split())
a = [int(x) for x in f]
a.sort()
weight = [0] * (sum(a) + 1)  # weight[i] - количество способов набрать вес i

for i in range(n):
    weight2 = weight.copy()
    for j in range(len(weight)):
        if weight[j] > 0:
            weight2[j + a[i]] += weight[j]
    weight2[a[i]] += 1
    weight = weight2

max_ways = max(weight)
max_weight = weight.index(max_ways)

print(weight[m], max_weight)
```
### Основные идеи
- **Динамическое программирование:** Используем массив `weight`, где `weight[i]` хранит количество способов набрать вес `i`.
- **Итеративный пересчёт:** Для каждой гири перебираем все возможные веса, которые можно было набрать до этого, и обновляем количество способов для новых весов.
## Пример 9: Камера хранения
### Условие
- В камере хранения есть `K` ячеек (≤ 1000).
- Поступают заявки от `N` пассажиров (≤ 1000), каждая заявка содержит время сдачи багажа и время освобождения ячейки (в минутах от начала суток, ≤ 1440).
- Багаж размещается в свободную ячейку с минимальным номером.
- Если свободных ячеек нет, пассажир уходит.
### Требуется
1. Определить количество пассажиров, которые смогут сдать багаж.
2. Найти номер ячейки, которая будет занята последней.
### Входные данные
- `K` — количество ячеек.
- `N` — количество пассажиров.
- Для каждого пассажира: время сдачи багажа и время освобождения ячейки.
### Решение
```python
f = open('24.txt')
k = int(f.readline())
n = int(f.readline())
a = []
for _ in range(n):
    st, end = map(int, f.readline().split())
    a.append([st, end])
a.sort()  # Сортируем заявки по времени сдачи багажа

camera = [0] * k  # Список для хранения времени освобождения ячеек
count = 0  # Количество пассажиров, сдавших багаж
last = 0  # Номер последней занятой ячейки

for i in range(n):
    st, end = a[i]
    for j in range(k):
        if camera[j] <= st:  # Если ячейка свободна
            camera[j] = end
            count += 1
            last = j + 1
            break

print(count, last)
```
### Основные идеи
- **Сортировка:** Сортируем заявки по времени сдачи багажа.
- **Моделирование:** Моделируем процесс сдачи багажа, отслеживая время освобождения каждой ячейки.

## Пример 10: Парковка
### Условие
- На парковке есть `L` мест для легковых автомобилей и `M` мест для микроавтобусов.
- Легковой автомобиль может занять любое свободное место.
- Микроавтобус может занять только место для микроавтобусов.
- Если подходящего места нет, автомобиль уезжает.
- Заданы время прибытия, длительность стоянки и тип каждого автомобиля.
### Требуется
1. Определить количество микроавтобусов, которые смогут припарковаться.
2. Найти общее количество автомобилей, которые уедут из-за отсутствия мест.
### Входные данные
- `N` — общее количество автомобилей.
- `L` — количество мест для легковых автомобилей.
- `M` — количество мест для микроавтобусов.
- Для каждого автомобиля: время прибытия, длительность стоянки, тип автомобиля (`A` — легковой, `B` — микроавтобус).
### Решение
```python
f = open('26.txt')
n, l, m = map(int, f.readline().split())
a = []
for _ in range(n):
    st, r, t = f.readline().split()
    a.append([int(st), int(st) + int(r), t])
a.sort()  # Сортируем автомобили по времени прибытия

park = [0] * (l + m)  # Список для хранения времени освобождения мест
bus = 0  # Количество припаркованных микроавтобусов
miss = 0  # Количество уехавших автомобилей

for i in range(n):
    st, end, t = a[i]
    if t == 'A':  # Легковой автомобиль
        for j in range(l + m):
            if park[j] <= st:
                park[j] = end
                break
        else:
            miss += 1
    elif t == 'B':  # Микроавтобус
        for j in range(l, l + m):
            if park[j] <= st:
                park[j] = end
                bus += 1
                break
        else:
            miss += 1

print(bus, miss)
```
### Основные идеи
- **Сортировка:** Сортируем автомобили по времени прибытия.
- **Моделирование:** Моделируем процесс парковки, отслеживая время освобождения каждого места.
- **Разделение мест:** Разделяем места для легковых автомобилей и микроавтобусов.

## Пример 11: Банкоматы
### Условие
- В операционном зале есть `N` банкоматов.
- В течение дня `M` клиентов хотят воспользоваться банкоматами.
- Клиенты обслуживаются в порядке очереди.
- Первый клиент в очереди подходит к первому освободившемуся банкомату.
- Обслуживание клиента может начаться в ту же минуту, когда банкомат освободится.
### Требуется
1. Определить наибольшее количество клиентов, обслуженных одним банкоматом за 24 часа.
2. Найти время начала обслуживания последнего клиента.
### Входные данные
- `N` — количество банкоматов.
- `M` — количество клиентов.
- Для каждого клиента: время начала обслуживания, время обслуживания.
### Решение
```python
f = open('26.txt')
m, n = map(int, f.readline().split())
a = []
for _ in range(n):
    st, r = map(int, f.readline().split())
    a.append([st, st + r, r])
# Сортируем по времени начала обслуживания, сохраняя порядок для одинакового времени
a.sort(key=lambda x: x[0])

bank = [0] * m  # Время освобождения банкоматов
bank_count = [0] * m  # Количество клиентов, обслуженных каждым банкоматом
last = 0  # Время начала обслуживания последнего клиента

for i in range(n):
    st, end, r = a[i]
    for j in range(m):
        if bank[j] <= st:
            bank[j] = end
            if st <= 1440:
                bank_count[j] += 1
                last = st
            break
    else:
        # Клиент ждёт, пока не освободится один из банкоматов
        min_time = min(bank)
        for j in range(m):
            if bank[j] == min_time:
                if st <= 1440:
                    bank_count[j] += 1
                    last = bank[j] if bank[j]>=st else st # Если банкомат освободился раньше, чем пришел клиент, берем время клиента, в ином случае, берем время, когда банкомат освободился
                bank[j] += r
                break

print(max(bank_count), last)
```
### Основные идеи
- **Сортировка:** Сортируем клиентов по времени начала обслуживания, сохраняя порядок для клиентов с одинаковым временем прихода.
- **Моделирование:** Моделируем процесс обслуживания клиентов, отслеживая время освобождения каждого банкомата и количество обслуженных клиентов.
- **Очередь:** Если все банкоматы заняты, клиент ждёт освобождения ближайшего.

## Пример 12: Варка зелья
### Условие
- В волшебной стране есть `P` котлов, пронумерованных от 1 до `P`. Изначально все котлы свободны.
- Гномы варят зелья в порядке очереди.
- Первый гном в очереди выбирает свободный котёл с наименьшим номером.
- Если котёл ранее не использовался, гном начинает варить зелье сразу.
- Если котёл уже использовался, гном ждёт 2 минуты после подхода к котлу, прежде чем начать варку.
- Одна порция зелья варится 1 минуту.
- На заварку одной порции зелья гном тратит 2 единицы маны.
- Если несколько гномов подходят одновременно, первым варит зелье гном с меньшим запасом маны.
- Гном, у которого осталось меньше 2 единиц маны, не может сварить зелье и уходит.
### Требуется
1. Определить общее количество порций зелья, сваренного гномами за сутки.
2. Найти наибольшее количество порций зелья, которое смог сварить один гном.
### Входные данные
- `D` — количество гномов (1 < `D` < 100 000).
- `P` — количество котлов (1 < `P` < 1000).
- Для каждого гнома: время подхода к котлам (в минутах от начала суток), количество маны.
### Решение
```python
f = open('26.txt')
d, p = map(int, f.readline().split())
a = []
for _ in range(d):
    st, mana = map(int, f.readline().split())
    if mana > 1:
        a.append([st, mana // 2])  # Переводим ману в количество порций зелья
# Сортируем по времени, при равенстве - по количеству порций
a.sort(key=lambda x: (x[0], x[1]))

kotel = [0] * p  # Время освобождения котлов
count = 0  # Общее количество сваренных порций
max_portions = 0  # Максимальное количество порций, сваренное одним гномом
gnome_portions = [0] * d  # Количество порций, сваренное каждым гномом

for i in range(len(a)):
    st, portions = a[i]
    for j in range(p):
        if kotel[j] <= st:
            end_time = st + portions if kotel[j] == 0 else st + 2 + portions
            if end_time <= 1440:
                count += portions
                gnome_portions[i] = portions
            else:
                portions_today = 1440 - (st if kotel[j] == 0 else st+2)
                count += portions_today
                gnome_portions[i] = portions_today
            kotel[j] = end_time # Обновляем время освобождения котла
            break
            
    max_portions = max(max_portions, gnome_portions[i])

print(count, max_portions)
```
### Основные идеи
- **Сортировка:** Сортируем гномов по времени подхода, а при равенстве времён — по возрастанию количества маны (порций зелья).
- **Моделирование:** Моделируем процесс варки зелья, отслеживая время освобождения каждого котла.
- **Учёт задержки:** Если котёл уже использовался, добавляем 2 минуты к времени начала варки.
- **Учёт маны:** Переводим количество маны в количество порций зелья и фильтруем гномов с недостаточным количеством маны.

## Пример 13: Заселение в отель
### Условие
- Отель состоит из домиков, расположенных линиями от моря. В каждой линии `K` домиков.
- Все домики изначально свободны.
- Заявки на заселение поступают в журнал, каждая заявка содержит час заезда и час выезда.
- Домик считается свободным в следующий час после выезда.
- Турист заселяется в первый свободный домик на ближайшей к морю линии, где есть свободные домики.
### Требуется
1. Определить максимальный номер линии, в которой будет заселяться хотя бы один домик.
2. Найти количество заселенных домиков в следующий час после заселения последнего туриста.
### Входные данные
- `K` — количество домиков в одной линии (1 < `K` < 100).
- `N` — количество заявок (1 < `N` < 10^6).
- Для каждой заявки: час заезда, час выезда.
### Решение
```python
from math import ceil

f = open('26.txt')
k, n = map(int, f.readline().split())
a = []
for _ in range(n):
    st, end = map(int, f.readline().split())
    a.append([st, end])
a.sort()  # Сортируем заявки по часу заезда

houses = [0] * 1000  # Время освобождения домиков
last_check_in = 0  # Время заселения последнего туриста

for i in range(n):
    st, end = a[i]
    for j in range(1000):
        if houses[j] < st:
            houses[j] = end
            last_check_in = st
            break
            
# Убираем пустые домики
houses = [x for x in houses if x != 0]
occupied_count = len([x for x in houses if x > last_check_in])
print(ceil(len(houses) / k), occupied_count)
```
### Основные идеи
- **Сортировка:** Сортируем заявки по часу заезда.
- **Моделирование:** Моделируем процесс заселения, отслеживая время освобождения каждого домика.
- **Линии:** Используем целочисленное деление на `K` с округлением вверх для определения номера линии.