### Формализация функций для поиска выигрышной стратегии

---

#### **Общая структура функции**

Функция `f(s, m)` определяет возможность выигрыша текущего игрока из позиции $S$ за оставшееся количество ходов $m$. 

- **Входные параметры:**
  - $S$ — текущее состояние игры (например, количество камней или сумма значений).
  - $m$ — количество оставшихся ходов.
  - Дополнительные параметры могут включать:
    - Предыдущий ход ($p$) для задач с ограничениями на повторение ходов.
    - Состояния нескольких куч ($a, b$).

- **Логика работы:**
  1. Проверка условия победы/поражения.
  2. Если ходы закончились ($m = 0$), возвращается результат.
  3. Рекурсивный перебор всех возможных ходов.
  4. Применение логики:
     - Если текущий игрок делает ход ($(m-1) \% 2 == 0$), то используется `any(h)` (хотя бы один выигрышный ход).
     - Если текущий игрок обороняется ($(m-1) \% 2 != 0$), то используется `all(h)` (все ходы должны быть проигрышными для противника).

---

### Примеры решений задач

---

#### **Игра с одной кучей**

##### **Условие:**
- Победа: $S \geq 25$.
- Ходы: $+2$, $\times 2$.

```python
def f(s, m):
    if s >= 25: return m % 2 == 0  # Условие победы
    if m == 0: return 0  # Ходы закончились
    h = [f(s+2, m-1), f(s*2, m-1)]  # Все возможные ходы
    return any(h) if (m-1) % 2 == 0 else all(h)  # Логика выигрыша
```

**Примеры запросов:**

1. **Задача 19:**  
   Минимальное $S$, чтобы Ваня выиграл первым ходом при любой игре Пети ($m=2$):
   ```python
   print([s for s in range(1, 25) if f(s, 2)])  # [11]
   ```

2. **Задача 20:**  
   $S$, где у Пети есть выигрышная стратегия:
   - Петя не может выиграть за 1 ход ($m=1$).
   - Петя выигрывает вторым ходом ($m=3$):
   ```python
   print([s for s in range(1, 25) if not f(s, 1) and f(s, 3)])  # [6, 9, 10]
   ```

3. **Задача 21:**  
   $S$, где:
   - У Вани выигрышная стратегия на втором или четвертом ходе ($m=2$ или $m=4$).
   - У Вани нет стратегии выиграть первым ходом ($m=2$):
   ```python
   print([s for s in range(1, 25) if not f(s, 2) and f(s, 4)])  # [7, 8]
   ```

---

#### **Игра с условием поражения**

##### **Условие:**
- Победа: $45 \leq S \leq 112$ — тот, кто сделал последний ход.
- Поражение: $S > 112$ — текущий игрок проигрывает.
- Ходы: $+2$, $\times 2$.

```python
def f(s, m):
    if 45 <= s <= 112: return m % 2 == 0  # Условие победы
    if s > 112: return m % 2 != 0  # Условие поражения
    if m == 0: return 0  # Ходы закончились
    h = [f(s+2, m-1), f(s*2, m-1)]  # Все возможные ходы
    return any(h) if (m-1) % 2 == 0 else all(h)  # Логика выигрыша
```

---

#### **Две кучи камней**

##### **Условие:**
- Ходы: добавить $+1$ в одну из куч или умножить её на 3.
- Победа:  $a + b \geq 45$.

```python
def f(a, b, m):
    if a + b >= 45: return m % 2 == 0  # Условие победы
    if m == 0: return 0  # Ходы закончились
    h = [f(a+1, b, m-1), f(a, b+1, m-1), f(a*3, b, m-1), f(a, b*3, m-1)]  # Все возможные ходы
    return any(h) if (m-1) % 2 == 0 else all(h)  # Логика выигрыша
```

**Пример:**
- Минимальное $S$, чтобы Ваня выиграл первым ходом после **неудачного** хода Пети ($m=2$):
  ```python
  print([s for s in range(1, 41) if f(4, s, 2)])  # [5...]
  #!: all -> any в "return any(h) if (m-1) % 2 == 0 else all(h)" 
  ```

---

#### **Две кучи с уменьшением**

##### **Условие:**
- Ходы: уменьшить на $-1$ или уменьшить вдвое (нечётное число округляется вверх).
- Победа: $a + b \leq 20$.
- Начальное состояние: $a = 10$, $b > 10$.

```python
def f(a, b, m):
    if a + b <= 20: return m % 2 == 0  # Условие победы
    if m == 0: return 0  # Ходы закончились
    h = [f(a-1, b, m-1), f((a+1)//2, b, m-1), f(a, b-1, m-1), f(a, (b+1)//2, m-1)]  # Все возможные ходы
    return any(h) if (m-1) % 2 == 0 else all(h)  # Логика выигрыша
```

---

#### **Игра с равенством куч**

##### **Условие:**
- Ходы: добавить в меньшую кучу $+1$ или $+3$.
- Победа: $a == b$.

```python
def f(a, b, m):
    if a == b: return m % 2 == 0  # Условие победы
    if m == 0: return 0  # Ходы закончились
    h = [f(a+1, b, m-1), f(a+3, b, m-1)] if a < b else [f(a, b+1, m-1), f(a, b+3, m-1)]  # Все возможные ходы
    return any(h) if (m-1) % 2 == 0 else all(h)  # Логика выигрыша
```

**Пример:**
- Задача 21: найти два $S$, где:
  - У Вани стратегия на 2 или 4 хода ($m=2, m=4$).
  - У Вани нет стратегии выиграть первым ходом ($m=2$).
  - Ваня выигрывает первым ходом после одного из ходов Пети:
    ```python
    print([s for s in range(1, 24) if not f(13, s, 2) and f(13, s, 4)])  # [5, 7, 19, 21]
    ```
  - Проверка третьего условия (ручной анализ):
    ```python
    print([s for s in range(1, 24) if not f(13, s, 2)])  # [7, 9, 11, 15, 17, 19]
    # Пересечение: [7, 19]
    ```

---

#### **Ограничение общего количества камней**

##### **Условие:**
- Общий запас: $S + T \leq 50$.
- Победа: $S \geq 41$.
- Ходы: $+1$, $+2$, $\times 2$ (если $S \leq 25$).

```python
def f(s, m):
    if s >= 41: return m % 2 == 0  # Условие победы
    if m == 0: return 0  # Ходы закончились
    h = [f(s+1, m-1), f(s+2, m-1)]  # Ходы +1 и +2
    if s <= 25: h += [f(s*2, m-1)]  # Ход *2, если можно
    return any(h) if (m-1) % 2 == 0 else all(h)  # Логика выигрыша
```

**Примеры запросов:**

1. Петя не выигрывает первым ходом ($m=1$), но выигрывает вторым ($m=3$):
   ```python
   print([s for s in range(1, 41) if not f(s, 1) and f(s, 3)])  # [10, 18, 19, 36]
   ```

2. Победа за 2 хода:
   ```python
   print([s for s in range(1, 41) if not f(s, 0) and f(s, 2)])  # [20, 38]
   ```

---

#### **Учёт предыдущего хода**

##### **Условие:**
- Ходы: $+1$, $+2$, $\times 3$.
- Ход нельзя повторять дважды подряд.
- Победа: $S \geq 140$.

```python
def f(s, m, p):
    if s >= 140: return m % 2 == 0  # Условие победы
    if m == 0: return 0  # Ходы закончились
    h = []
    if p != "+1": h += [f(s+1, m-1, "+1")]  # Ход +1
    if p != "+2": h += [f(s+2, m-1, "+2")]  # Ход +2
    if p != "*3": h += [f(s*3, m-1, "*3")]  # Ход *3
    return any(h) if m % 2 != 0 else all(h)  # Логика выигрыша
```

**Пример:**
- Проверка выигрышной стратегии:
  ```python
  print(f(s, 2, ""))  # Проверка для Вани на втором ходу
  ```

---

### Общие замечания

1. **Рекурсивный подход:**  
   Ключевая идея — рекурсивно проверять все возможные ходы и их последствия.

2. **Оптимизация:**  
   Для больших диапазонов $S$ или сложных правил можно использовать мемоизацию (`@lru_cache` из модуля `functools`) для ускорения вычислений.

3. **Анализ результатов:**  
   После расчета всех возможных состояний, используйте списковые включения для фильтрации нужных $S$, соответствующих условиям задачи.
4. **Нестандартные формулировки:**
  Нестандартные формулировки стоит проверять или решать аналитически (например, 2-й ход Пети неудачный (те. это не решается заменой all->any))
